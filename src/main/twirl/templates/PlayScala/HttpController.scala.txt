@(service: akka.grpc.gen.scaladsl.Service, methods: Vector[play.grpc.gen.scaladsl.GrpcMethodInfo], context0: String)

// Generated by Play gRPC Gateway. Generates every time you build the project. DO NOT EDIT.
package @service.packageName

import scala.concurrent.{ExecutionContext, Future}

import play.api.mvc._
import javax.inject.Inject
import com.typesafe.config.Config

import @{service.packageName}._

@defining(service.name) { serviceName =>

class @{serviceName}Controller @@Inject()(config: Config, context: @{context0})(implicit ec: ExecutionContext) extends InjectedController {

   //Parses json request body
   private def parse[T <: scalapb.GeneratedMessage: scalapb.GeneratedMessageCompanion](req: Request[AnyContent]): Either[String, T] =
     req.body.asJson match {
       case Some(json) =>
         val req: Either[String, T] =
           try Right(scalapb.json4s.JsonFormat.fromJsonString[T](json.toString()))
           catch {
             case scala.util.control.NonFatal(ex) => Left(ex.getMessage)
           }
         req
       case None => Left("Empty body")
     }

  @for(e <- methods) {
    def @{e.name} (@{e.inputType}) = Action.async { implicit req =>
      @if(e.inputType.nonEmpty && e.verbName == "GET") {
        context.@{e.name}(@{e.inputType})
      }
      @if(e.inputType.isEmpty && e.verbName == "GET") {
        context.@{e.name}()
      }
      @if(e.inputType.isEmpty && e.verbName == "POST") {
        parse[@{e.inputProto}](req) match {
          case Right(body) => context.@{e.name}(body)
          case Left(error) => Future.failed(new Exception(error))
        }
      }
      @if(e.inputType.nonEmpty && e.verbName == "POST") {
        parse[@{e.inputProto}](req) match {
          case Right(body) => context.@{e.name}(@{e.inputType}, body)
          case Left(error) => Future.failed(new Exception(error))
        }
      }
    }
  }
}
}
