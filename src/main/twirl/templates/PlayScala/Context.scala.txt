@(serviceName: String, packageName: String, methods: Vector[play.grpc.gen.scaladsl.GrpcMethodInfo])
/*
 * Generated by Play gRPC Gateway.
 * As long as this file exists it will not be re-generated.
 * It's a starting point for developing your business logic.
 */

package @packageName

import play.api.mvc.Result
import play.api.mvc._

import javax.inject.Inject

import scala.concurrent.{ExecutionContext, Future}

class @{serviceName}Context @@Inject()()(implicit ec: ExecutionContext) {
@for(e <- methods) {
 @if(e.inputType.nonEmpty && e.verbName == "GET") {
 def @{e.name} (@{e.inputType}): Future[Result] = Future {
  //Place your business logic here.
  val r: @{e.outputProto} = ???
  Results.Ok(r.toProtoString)
 }
 }
 @if(e.inputType.isEmpty && e.verbName == "GET") {
  def @{e.name}(): Future[Result] = Future {
   //Place your business logic here.
   val r: @{e.outputProto} = ???
   Results.Ok(r.toProtoString)
  }
  }
 @if(e.inputType.nonEmpty && e.verbName == "POST") {
 def @{e.name} (@{e.inputType}, body: @{e.inputProto}): Future[Result] = Future {
  //Place your business logic here.
  Results.Ok(body.toProtoString)
 }
 }
 @if(e.inputType.isEmpty && e.verbName == "POST") {
  def @{e.name} (body: @{e.inputProto}): Future[Result] = Future {
   //Place your business logic here.
   Results.Ok(body.toProtoString)
  }
  }
}
}
